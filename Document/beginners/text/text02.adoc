= 要素技術とモデルを開発に使おう: 要素技術をシステムに組込もう
include::revdate.inc[]
include::front_matter.adoc[]
include::image_size_matter.adoc[]

== sample03（ライントレーサー）を動かしてみよう

On/Off制御を使った簡単なライントレースのサンプルを動かしてみましょう。

. `sample03` をビルドし、EV3本体に転送します
. 黒い線の上から走行するよう置きます
. 反時計回りにラインの外周に沿って走行します
. 左ボタンを押すと停止します
. 環境に合わせて、カラーセンサーのしきい値（ `mThreshold` ）を調整しましょう

.トレーサーの走行の様子
image::トレーサーの走行の様子.png[running_tracer,{three-quarters-width},{image-align}]

== sample03のコードを見てみよう

* `main_task` とは別にトレース用のタスク（ `tracer_task` ）を使っています
* 1回分のトレース動作をする `tracer_task` を繰り返し動作させるために、周期ハンドラを使っているのがわかります

[source,cpp]
.`sample03/app.cfg` （タスク構成）
----
include::{sourcedir}/sample03/app.cfg[]
----

ifdef::backend-deckjs[]
<<<
endif::[]

[source,cpp,linenums,start=1]
.`sample03/app/Tracer.h`
----
include::{sourcedir}/sample03/app/Tracer.h[]
----

ifdef::backend-deckjs[]
<<<
endif::[]

[source,cpp,linenums,start=13]
.`sample03/app/Tracer.cpp` （抜粋）
----
include::{sourcedir}/sample03/app/Tracer.cpp[tags=tracer_impl]
----
<1> 明るい時（ライン外）の処理、左に曲がっています
<2> 暗い時（ライン上）の処理、右に曲がっています

ifdef::backend-deckjs[]
<<<
endif::[]

ifdef::backend-deckjs[]
[source,cpp,linenums,start=1]
.`sample03/app.cpp` （その１）
----
include::{sourcedir}/sample03/app.cpp[tags=tracer_def]
----

ifdef::backend-deckjs[]
<<<
endif::[]

[source,cpp,linenums,start=22]
.`sample03/app.cpp` （その２）
----
include::{sourcedir}/sample03/app.cpp[tags=main_task]
----
endif::[]

ifdef::backend-html5,backend-pdf[]
[source,cpp,numbered]
.`sample03/app.cpp`
----
include::{sourcedir}/sample03/app.cpp[]
----
endif::[]

== sample03のクラス図を描いてみよう

`sample03` の構造を表すクラス図を描いてみよう

* `sample01` のクラス図を複製して修正するとよいでしょう
* タスク（ `main_task` 、`tracer_task` ）と周期ハンドラ（ `tracer_cyc` ）は {cpp} のクラスではありませんが、この演習の便宜上クラスを使って表しておきましょう
* `app` パッケージを追加して、そこに `Tracer` クラスを追加しましょう
** 名前空間で親を表示しておくとパッケージ名が可視化できます
* ev3apiライブラリのクラスの詳細（属性やメソッド）は非表示にしておくとコンパクトになるでしょう
* 属性の初期値をプロパティから入力して、表示するように設定するとよいでしょう


== 作成したsample03のクラス図

.`sample03` のクラス図
image::sample03のクラス図.png[{three-quarters-width},{image-align}]

== sample03の振舞いの図を描いてみよう

クラス図だけでは、どのように走行しているかわかりません。 +
あるメソッドがどのような振舞いをするかを図に描くには、アクティビティ図やステートマシン図を使います。

ここでは、 `Tracer` クラスの `run` メソッドの振舞いを表すのにアクティビティ図を使ってみましょう。

.`Tracer` クラスの `run` メソッドのアクティビティ図の作成手順:
* `run` メソッドの処理の流れがわかるよう、アクティビティ図を使ってみます
* メニューから「図」→「アクティビティ図」→「新規アクティビティ図」で作成します
* プロパティのベースタブで、図の名前を「 `Tracer` クラスの `run` メソッドのアクティビティ図」としましょう
* 処理には「アクションノード」を、条件分岐には「ディシジョンノード」を使います
** 条件による分岐では、判断条件を「ガード条件」で表します
* 処理の開始場所がわかるよう「開始ノード」を使います
* 処理の終了場所が判るよう「終了ノード」を使います

== 作成したrunメソッドのアクティビティ図

.`Tracer` クラスの `run` メソッドのアクティビティ図
image::sample03のTracerクラスのrunメソッドのアクティビティ図.png[{three-quarters-width},{image-align}]

== sample03の課題を検討しよう

.`sample03` のライントレースは…
* ライン上かライン外かで左右のモーターをOn/Offする方法で左右に曲がりながら走行していました
* 左右に揺れながら走行するので、姿勢が安定せず速度を上げると不安定になってしまうでしょう

----
もう少し滑らかに走行するには、どんなことを調べたり、考えたりすればよいでしょうか。
----

== カラーセンサーの値を詳しく調べてみよう

もう少し滑らかに走行する方法を考えるために、カラーセンサーの動作を少し調査してみましょう。

.測り方1：組込みのPort Viewを使う
. SDカードを挿入していない状態でEV3本体を起動します
. 「Port View」を選択して、中央ボタンを押します
. 左右ボタンを操作してカラーセンサーのポートを選択します
. カラーセンサーの取得値が表示されます
. ロボットを手でライン上からライン外へゆっくり移動させながら、カラーセンサーの取得値がどのように変化するか確認しましょう
. センサーとラインの位置と調べた値との関係をまとめて図にしておくとよいでしょう

ifdef::backend-deckjs[]
<<<
endif::[]

.測り方2：helloev3を使う
. EV3RTの配布パッケージには、workspaceに「helloev3」というサンプルが含まれています
. 「helloev3」をmakeしてEV3本体に転送し、メニューから選んで起動します
. 「Connect Device」→「Connect Sensor」で「Sensor Port 3」を「Color Sensor」に設定します
. 最初のメニューに戻って「Test sensor」→「Sensor port 3」を選択します
. 「Reflect」を選択すると、赤外線ランプが点灯し、センサーが取得した明るさが表示されます
. ロボットを手でライン上からライン外へゆっくり移動させながら、カラーセンサーの取得値がどのように変化するか確認しましょう
. センサーとラインの位置と調べた値との関係をまとめて図にしておくとよいでしょう

== 滑らかに走る方法を考えてみよう

.ラインの境界付近でのカラーセンサーの値:
* カラーセンサーの取得値は、白と黒の中間の値で徐々に変化しています
* 中間の値の場合、まだラインの境界付近から大きくずれていないといえます
* 大きくずれていないならば、旋回する度合いをその分小さくすると、ブレが減って滑らかになりそうです

.旋回する度合いを小さくするには:
* 左右の旋回を切替えるとき、PWM値をいきなり「0」にして止めてしまわないで、中間値の大きさに応じて小さくしてみたらどうでしょうか
* カラーセンサーの目標値を白と黒の真ん中にしておき、実測値との差を求め、差の大小に応じて左右のモーターのPWM値を加減すれば、ズレに応じて旋回の度合いを調整できそうです

== プログラムで使えるよう整理しよう

いま考えているような制御の方法を「比例制御」といいます。 +
前のページで考えたことを、プログラムで計算できるよう整理しましょう。

* 偏差 ＝ カラーセンサーの測定値 - カラーセンサーの目標値
* 調整値 = 偏差に比例した値（偏差に係数をかけた値）
* 調整後の左のモーターのPWM値 = 基準のPWM値 - 調整値
* 調整後の右のモーターのPWM値 = 基準のPWM値 + 調整値

調整値を求めるときに使う係数を「比例ゲイン（Kp）」、 +
調整後の左右のモーターのPWM値を「操作量」といいます。

== これでうまくいきそうでしょうか

アイディアは整理できましたが…

* まだ、効果的な方法かどうか確かめられていません
* どのようにプログラムを作れば実現できるかわかっていません
* どのくらいの値に調整すればよいかわかっていません

=== アイディアの妥当性を確かめるには

----
実験しましょう！

考えたことを実際に試してみて、効果や実現方法を決めましょう。
----

== sample04を作成しよう（比例制御の実験）

. サンプルコードの `sample03` ディレクトリをそっくりコピーして `sample04` ディレクトリを作ります
. 考えた方法に合わせて `app/Tracer.cpp` の `run` メソッドを編集します
. 編集が済んだら、期待したとおりに動くかどうか確認してみましょう
. うまくいかない時は、定数の値をいろいろ変更して実験してみるとよいでしょう

作成したコードは次ページに掲載してあります。 +
定数は、みなさんで調整してみてください。

== 実験用に作成したrunメソッドの例

[source,cpp,linenums,start=18]
.`sample04/app/Tracer.cpp` （runメソッドの部分を抜粋）
----
void Tracer::run() {
  const float Kp = 0.83;        // <1>
  const int target = 10;        // <2>
  const int bias = 0;           // <3>

  msg_f("running...", 1);
  int diff = colorSensor.getBrightness() - target;
  float turn = Kp * diff + bias;
  leftWheel.setPWM(pwm - turn);
  rightWheel.setPWM(pwm + turn);
}
----
<1> 比例係数（1より小さい値で検討してみましょう）
<2> 白と黒の中間値を目標値として設定（実際に測った値を使ってみましょう）
<3> 調整値にいつも一定の値（バイアス）を追加しておきたい場合に設定します

== 実験はうまくいきましたか？

これでうまくいったので、オッケーでしょうか。

* `sample04` で実験して実現したことは、モデル図のどこに反映されていますか
* `sample03` のモデル図となにが変わったか考えてみましょう

=== まだ実験しか終わっていなかった！

どうやら、実験は成功しましたが…、 +
その結果を、システムに組込んで使う仕事がまだだったようです。

== 実験の成果をモデル図に反映する

実験した結果を反映したモデル図を作成しましょう。

. **astah* ** で `sample03` のプロジェクトを「ファイル」→「プロジェクトの別名保存」で `sample05` として保存します
. クラス図の名前を `sample05のクラス図` に変更します
. アクティビティ図を編集して、実験の時に確立した処理（次の2つを順に処理する）に合わせます
** 比例制御の調整値の計算をしているところ
** 実際に走行させるところ
. 調整値の計算は、走行そのものとは別の処理です名前をつけて分けたほうがよいでしょう
** 処理を分けて `calc_prop_value` メソッドを作り、これを使うようにしましょう

== 実験を反映したアクティビティ図

.実験を反映した `Tracer` クラスの `run` メソッドのアクティビティ図
image::sample05のTracerクラスのrunメソッドのアクティビティ図.png[{three-quarters-width},{image-align}]

== 実験を反映したクラス図

* クラス図を編集して `Tracer` クラスに `calc_prop_value` メソッドを追加しましょう。
* 内部で使う操作なので private なメソッドにしてあることに注意しましょう。

.`sample05` のクラス図
image::sample05のクラス図_marked.png[{three-quarters-width},{image-align}]

== sample05のコードを作成する

モデル図に合わせて、コードを変更しましょう。

. サンプルコードの `sample04` ディレクトリをそっくりコピーして `sample05` ディレクトリを作りましょう
. クラス図に従って `Tracer.h` に `calc_prop_value` メソッドを追加します
. `Tracer.cpp` にも `calc_prop_value` メソッドを追加します
. `Tracer` クラスの `run` メソッドを `calc_prop_value` メソッドを使うように修正します

作成したコードは次ページに掲載してあります。

コードが作成できたら、ビルドして、動作を確認しましょう。

ifdef::backend-deckjs[]
<<<
endif::[]

[source,cpp,linenums,start=15]
.`sample05/app/Tracer.h`
----
include::{sourcedir}/sample05/app/Tracer.h[tags=tracer_h_private]
----
<1> `calc_prop_value` メソッドを追加した

ifdef::backend-deckjs[]
<<<
endif::[]

[source,cpp,linenums,start=19]
.`sample05/app/Tracer.cpp` （ `calc_prop_value` メソッド）
----
include::{sourcedir}/sample05/app/Tracer.cpp[tags=tracer_calc_prop]
----
<1> 比例係数
<2> 目標値とした白・黒の中間値
<3> 偏差を求める
<4> 調整値を求めて返す

ifdef::backend-deckjs[]
<<<
endif::[]

[source,cpp,linenums,start=29]
.`sample05/app/Tracer.cpp` （ `run` メソッド）
----
include::{sourcedir}/sample05/app/Tracer.cpp[tags=tracer_run]
----
<1> 比例制御の調整値を求める
<2> 基準値と調整値を使って操作量を求める


== ここまでのまとめ

`sample05` のモデル図とコードを作成するまでにどんなことをやったでしょうか。

* 元になる `sample03` を動かしてみました
** 周期ハンドラを使って周期的に処理しました
** ファイルをクラスごとに分け、パッケージにディレクトリを割当てました
* 滑らかに走行するためのアイディアを実験しました（ `sample04` ）
** カラーセンサーの値の変化を調べました
** 調べた結果を使って滑らかに走行できるか実験しました
* 実験した結果を使ってモデルを更新しました（ `sample05` ）
** 更新したモデル図に合わせてコードを作成し、動作を確認しました


== 要素技術がモデルの要素になっていること

モデル図に要素技術を活用している様子がわかるようにするには：

* モデル図上に要素技術を実現している構成要素として登場しているべきでしょう
* モデル図に登場するには、クラスやメソッドなど、モデル図の要素として表す必要があります


=== 要素技術をシステムに組込む手順

.次のような検討手順で進めてみるとよいでしょう:
. アイディアを出す、必要な情報を取得する・調査します
. 実験してアイディアの効果を確かめます
. 得られた結果を元のシステムのモデル図に「名前をつけて」組込みます
. 更新したモデル図に合わせてコードを作成します

include::colophon.inc[]
